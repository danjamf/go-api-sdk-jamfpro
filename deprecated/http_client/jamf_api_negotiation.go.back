// jamf_api_negotiation.go
package http_client

import (
	"encoding/json"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"strings"
)

// ContentType represents the type of content used in HTTP communication (e.g., JSON, XML).
type ContentType string

// Predefined content types used for API communication.
const (
	JSON ContentType = "application/json"
	XML  ContentType = "application/xml"
)

// determineAPIType returns the content type based on the API type and the HTTP method.
func determineAPIType(endpoint string, logger Logger, debugMode bool) string {
	if strings.Contains(endpoint, "/JSSResource") {
		if debugMode {
			logger.Debug("Determined API type based on the endpoint", "Endpoint", endpoint, "APIType", "Classic")
		}
		return "Classic"
	} else if strings.Contains(endpoint, "/api") {
		if debugMode {
			logger.Debug("Determined API type based on the endpoint", "Endpoint", endpoint, "APIType", "JamfPro")
		}
		return "JamfPro"
	}
	// Default or error handling
	if debugMode {
		logger.Warn("Unable to determine API type based on the endpoint", "Endpoint", endpoint, "Default", "Unknown")
	}
	return "Unknown"
}

// DetermineContentType determines the content type to use based on the API type and the HTTP method.
// Used to decide how the body of the HTTP request is encoded (as JSON or XML)
func DetermineContentType(apiType string, httpMethod string) ContentType {
	if strings.EqualFold(apiType, "Classic") {
		if strings.EqualFold(httpMethod, "GET") {
			return JSON
		}
		if strings.EqualFold(httpMethod, "POST") || strings.EqualFold(httpMethod, "PUT") {
			return XML
		}
	}
	// Default to JSON for Jamf Pro API and other methods for Classic API
	return JSON
}

// marshallRequest takes the provided request body, API type, and method and returns the marshalled data in the appropriate format (JSON or XML).
// If marshalling fails, it returns an error. This function is designed to handle the specific marshalling requirements of the Jamf API.
func (c *Client) marshallRequest(body interface{}, apiType, method string) ([]byte, error) {
	contentType := DetermineContentType(apiType, method)

	// Marshal the request body based on the content type
	var requestData []byte
	var err error
	if body != nil {
		switch contentType {
		case JSON:
			requestData, err = json.Marshal(body)
		case XML:
			requestData, err = xml.Marshal(body)
		default:
			err = fmt.Errorf("unsupported content type: %s", contentType)
		}
		if err != nil {
			c.logger.Error("Failed to marshal request body", "error", err, "content type", contentType)
			return nil, err
		}
	}

	return requestData, nil
}

// UnmarshalResponse decodes the response body (JSON or XML) based on the JAMF API type and HTTP method.
// For the Classic API: GET requests will always decode in JSON format. PUT and POST requests will always decode in XML format.
// For the JamfPro API, all requests will always decode in JSON format.
func UnmarshalResponse(apiType, method string, resp *http.Response, out interface{}, logger Logger, debugMode bool) error {
	// Read and store the response body
	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return err
	}

	// In debug mode, print the raw response body
	if debugMode {
		logger.Debug("Raw response body", "ResponseBody", string(bodyBytes))
	}

	// Decode based on the API type and HTTP method
	if apiType == "Classic" {
		if method == http.MethodGet {
			if debugMode {
				logger.Debug("Decoding response body in JSON format", "APIType", "Classic", "HTTPMethod", http.MethodGet)
			}
			return json.Unmarshal(bodyBytes, out)
		} else { // For non-GET methods like PUT and POST, always expect XML for Classic API
			if debugMode {
				logger.Debug("Decoding response body in XML format", "APIType", "Classic", "HTTPMethod", method)
			}
			return xml.Unmarshal(bodyBytes, out)
		}
	} else if apiType == "JamfPro" { // Always expect JSON for Jamf Pro API
		if debugMode {
			logger.Debug("Decoding response body in JSON format", "APIType", "JamfPro", "HTTPMethod", method)
		}
		return json.Unmarshal(bodyBytes, out)
	}
	return nil
}
